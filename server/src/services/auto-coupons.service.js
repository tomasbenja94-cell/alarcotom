/**
 * Sistema de Cupones Automáticos por Comportamiento
 */

import prisma from '../utils/prisma.js';
import logger from '../utils/logger.js';
import crypto from 'crypto';

const TRIGGERS = {
  FIRST_ORDER: 'first_order',
  BIRTHDAY: 'birthday',
  INACTIVE_30_DAYS: 'inactive_30_days',
  INACTIVE_60_DAYS: 'inactive_60_days',
  ORDER_COUNT_5: 'order_count_5',
  ORDER_COUNT_10: 'order_count_10',
  TOTAL_SPENT_10K: 'total_spent_10k',
  TOTAL_SPENT_50K: 'total_spent_50k',
  CART_ABANDONED: 'cart_abandoned',
  BAD_REVIEW: 'bad_review',
  REFERRAL_SUCCESS: 'referral_success',
};

class AutoCouponsService {
  /**
   * Generar código único
   */
  generateCode(prefix = 'AUTO') {
    const random = crypto.randomBytes(3).toString('hex').toUpperCase();
    return `${prefix}${random}`;
  }

  /**
   * Crear cupón automático para un cliente
   */
  async createAutoCoupon(customerPhone, storeId, trigger, config) {
    const {
      discountType = 'percentage',
      discountValue = 10,
      minOrderAmount = 0,
      validDays = 7,
      maxUses = 1,
    } = config;

    const code = this.generateCode(trigger.substring(0, 3).toUpperCase());
    const validUntil = new Date(Date.now() + validDays * 24 * 60 * 60 * 1000);

    const coupon = await prisma.coupon.create({
      data: {
        code,
        storeId,
        discountType,
        discountValue,
        minOrderAmount,
        validUntil,
        usageLimit: maxUses,
        customerPhone, // Cupón personal
        trigger,
        isAutoGenerated: true,
      },
    });

    // Registrar envío
    await prisma.autoCouponLog.create({
      data: {
        couponId: coupon.id,
        customerPhone,
        storeId,
        trigger,
      },
    });

    logger.info({ customerPhone, trigger, code }, 'Auto coupon created');
    return coupon;
  }

  /**
   * Verificar y crear cupones por triggers
   */
  async checkAndCreateCoupons(customerPhone, storeId, event, eventData = {}) {
    const rules = await this.getActiveRules(storeId);
    const createdCoupons = [];

    for (const rule of rules) {
      if (await this.shouldTrigger(customerPhone, storeId, rule, event, eventData)) {
        // Verificar que no se haya enviado este tipo recientemente
        const recentCoupon = await prisma.autoCouponLog.findFirst({
          where: {
            customerPhone,
            storeId,
            trigger: rule.trigger,
            createdAt: { gte: new Date(Date.now() - rule.cooldownDays * 24 * 60 * 60 * 1000) },
          },
        });

        if (!recentCoupon) {
          const coupon = await this.createAutoCoupon(customerPhone, storeId, rule.trigger, rule);
          createdCoupons.push(coupon);

          // Notificar al cliente
          await this.notifyCustomer(customerPhone, coupon, rule);
        }
      }
    }

    return createdCoupons;
  }

  /**
   * Verificar si debe dispararse el trigger
   */
  async shouldTrigger(customerPhone, storeId, rule, event, eventData) {
    switch (rule.trigger) {
      case TRIGGERS.FIRST_ORDER:
        if (event !== 'order_completed') return false;
        const orderCount = await prisma.order.count({
          where: { customerPhone, storeId, status: 'delivered' },
        });
        return orderCount === 1;

      case TRIGGERS.ORDER_COUNT_5:
      case TRIGGERS.ORDER_COUNT_10:
        if (event !== 'order_completed') return false;
        const count = await prisma.order.count({
          where: { customerPhone, storeId, status: 'delivered' },
        });
        const target = rule.trigger === TRIGGERS.ORDER_COUNT_5 ? 5 : 10;
        return count === target;

      case TRIGGERS.TOTAL_SPENT_10K:
      case TRIGGERS.TOTAL_SPENT_50K:
        if (event !== 'order_completed') return false;
        const total = await prisma.order.aggregate({
          where: { customerPhone, storeId, status: 'delivered' },
          _sum: { total: true },
        });
        const threshold = rule.trigger === TRIGGERS.TOTAL_SPENT_10K ? 10000 : 50000;
        const prevTotal = (total._sum.total || 0) - (eventData.orderTotal || 0);
        return prevTotal < threshold && (total._sum.total || 0) >= threshold;

      case TRIGGERS.BAD_REVIEW:
        if (event !== 'review_submitted') return false;
        return eventData.rating <= 2;

      case TRIGGERS.CART_ABANDONED:
        return event === 'cart_abandoned';

      case TRIGGERS.BIRTHDAY:
        return event === 'birthday_check';

      default:
        return false;
    }
  }

  /**
   * Obtener reglas activas de una tienda
   */
  async getActiveRules(storeId) {
    const settings = await prisma.storeSettings.findUnique({ where: { storeId } });
    
    if (!settings?.autoCouponRules) {
      return this.getDefaultRules();
    }

    try {
      return JSON.parse(settings.autoCouponRules);
    } catch {
      return this.getDefaultRules();
    }
  }

  /**
   * Reglas por defecto
   */
  getDefaultRules() {
    return [
      {
        trigger: TRIGGERS.FIRST_ORDER,
        discountType: 'percentage',
        discountValue: 15,
        validDays: 30,
        cooldownDays: 365,
        message: '¡Gracias por tu primera compra! Aquí tienes un 15% para tu próximo pedido',
        enabled: true,
      },
      {
        trigger: TRIGGERS.ORDER_COUNT_5,
        discountType: 'percentage',
        discountValue: 10,
        validDays: 14,
        cooldownDays: 90,
        message: '¡5 pedidos! Te ganaste un 10% de descuento',
        enabled: true,
      },
      {
        trigger: TRIGGERS.INACTIVE_30_DAYS,
        discountType: 'percentage',
        discountValue: 20,
        validDays: 7,
        cooldownDays: 30,
        message: '¡Te extrañamos! Volvé con un 20% de descuento',
        enabled: true,
      },
      {
        trigger: TRIGGERS.BAD_REVIEW,
        discountType: 'fixed',
        discountValue: 500,
        validDays: 14,
        cooldownDays: 30,
        message: 'Lamentamos tu experiencia. Aquí tienes $500 para darnos otra oportunidad',
        enabled: true,
      },
    ];
  }

  /**
   * Notificar al cliente
   */
  async notifyCustomer(customerPhone, coupon, rule) {
    // TODO: Integrar con WhatsApp/Email/Push
    logger.info({ customerPhone, code: coupon.code }, 'Customer notified about coupon');
  }

  /**
   * Job para verificar clientes inactivos
   */
  async checkInactiveCustomers(storeId) {
    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
    const sixtyDaysAgo = new Date(Date.now() - 60 * 24 * 60 * 60 * 1000);

    // Clientes inactivos 30 días
    const inactive30 = await prisma.order.groupBy({
      by: ['customerPhone'],
      where: {
        storeId,
        status: 'delivered',
      },
      _max: { createdAt: true },
      having: {
        createdAt: { _max: { lt: thirtyDaysAgo, gte: sixtyDaysAgo } },
      },
    });

    for (const customer of inactive30) {
      await this.checkAndCreateCoupons(
        customer.customerPhone,
        storeId,
        'inactivity_check',
        { daysSinceLastOrder: 30 }
      );
    }

    return { processed: inactive30.length };
  }

  /**
   * Configurar reglas de una tienda
   */
  async setRules(storeId, rules) {
    await prisma.storeSettings.update({
      where: { storeId },
      data: { autoCouponRules: JSON.stringify(rules) },
    });
    return rules;
  }

  /**
   * Estadísticas de cupones automáticos
   */
  async getStats(storeId) {
    const [total, used, revenue] = await Promise.all([
      prisma.coupon.count({ where: { storeId, isAutoGenerated: true } }),
      prisma.coupon.count({ where: { storeId, isAutoGenerated: true, usageCount: { gt: 0 } } }),
      prisma.order.aggregate({
        where: {
          storeId,
          coupon: { isAutoGenerated: true },
        },
        _sum: { total: true },
      }),
    ]);

    return {
      totalGenerated: total,
      totalUsed: used,
      conversionRate: total > 0 ? Math.round((used / total) * 100) : 0,
      revenueGenerated: revenue._sum.total || 0,
    };
  }
}

export const autoCouponsService = new AutoCouponsService();
export default autoCouponsService;

